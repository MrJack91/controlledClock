% !TeX encoding=utf8
% !TeX spellcheck = de-CH

\chapter{Dokumentation}
In diesem Kaptiel wird der Aufbau der Implementation mit den verschiedenen Komponenten näher beschrieben.

%TODO: Finish
\section{Übersicht der Struktur}
\subsection{Server Side}
Das Backend unter \textit{/code/server} ist in folgende Module aufgeteilt:
%TODO: Ergänzung weiterer Module
\begin{itemize}
\item {\textbf{Main} - dcf77\_main.c} \\
Das Main-Modul verbindet alle übrigen Module miteinander und stellt die Kommunikation untereinander sicher.
\item {\textbf{DCF77 Reader} - dcf77\_reader.c} \\
Der Reader liest die Daten von der USB-Schnittstelle zum DCF77 und übergibt diese dem Decoder.
\item {\textbf{DCF77 Decoder} - dcf77\_decoder.c}\\
Der Decoder decodiert laufend die erhaltenen Daten von der USB-Schnittstelle und generiert auf den Anfang einer Minute einen entsprechenden Timestamp. Voraussetzung dafür ist, dass die genügend Daten empfangen wurden und keine Fehler aufgetreten sind. Der Timestamp wird anschliessend dem Clock-Modul zur Synchronisation übergeben.

\item {\textbf{Server} - SimpleSocketServer.c}\\
Der Server bietet eine Web-Schnittstelle via Sockets an, welche den Timestamp, gemäss ISO 8601\footnote{Spezifikation: http://www.iso.org/iso/home/standards/iso8601.htm}, als JSON anbietet. Der Timestamp wird aus der aktuellen Zeit aus dem Clock-Modul erzeugt.

\item {\textbf{Clock} - Clock.c}\\
Das Clock-Modul bildet eine eigenständige, laufende Uhr. Wird ein DCF77-Signal erfolgreich decodiert, so werden die Informationen (Datum und Zeit) auf den Start einer Minute, sekundengenau übernommen. Ab dann läuft die Uhr wieder autonom weiter.
\end{itemize} 

\subsection{Client Side}
Das Frontend ist eine simple Web-Oberfläche, welche die entsprechenden GUI-Elemente darstellt und via HTTP-Requests in bestimmten Zeitintervallen die aktuelle Zeit vom Server abruft.

\section{Modul-Dokumentation}
Die Funktionsweise, der einzelnen Module, wurde innerhalb des Codes dokumentiert und beschrieben. Nachfolgend werden die wichtigsten Aspekte der Umsetzung kurz erläutert.

\subsection{DCF Reader}
Source: \textit{/code/server/dcf77\_reader.c}\\
Via Schnittstelle zum "`Expert mouse CLOCK USB II"' wird der Status der Warteschlange  solange abgerufen, bis mindestens ein Wert (8-Bit Integer) bereit ist.
Sobald ein Wert vorhanden ist, wird dieser ausgelesen und direkt dem Decoder übergeben.

Da das Programm seriell abläuft, ist es wichtig, dass wir pro Verarbeitung nicht länger als eine Sekunde benötigen, denn dann muss das nächste Signal verarbeitet werden können.
Dadurch das die ganze Software in C vollzogen wird, und keine sehr aufwändigen Berechnungen erfolgen müssen, stellt dies kein Problem dar.

\subsubsection{standalone}
Source: \textit{/code/server/dcf77\_reader\_standalone.c}\\
Diese Version des Readers liest alle empfangene Werte in einen Buffer und gibt sie am Ende zurück. So können veraltete, aber echte Daten für das Debugging verwendet werden.

\subsection{DCF Decoder}
Source: \textit{/code/server/dcf77\_decoder.c}\\
Der Decoder mappt jedes erhaltende Byte direkt einem Bit zu. Laufend werden aus den verfügbaren Bits, via 4 Paritäsbit, gültige Daten gesucht. Ein vollständiges Datum besteht aus 39 fortlaufenden Bits.
Wird ein gültiges Datum gefunden, so wird dies direkt der Systemclock übergeben.

\subsection{Simple Web Server}
Source: \textit{/code/server/SimpleSocketServer.c}\\
Aus dem Main-Modul heraus wird ein simpler Socket Server in einem separaten Thread gestartet. Der Server arbeitet nur auf einem Thread. Multithreading muss in C selbst implementiert werde. Dies haben wir aufgrund der Rahmenbindungen bewusst nicht implementiert. Wird eine Verbindung zum Server hergestellt wird mit Hilfe einer Hilfs-Funktion und der Zeit aus dem Clock-Modul ein JSON-String generiert und an den Client zurückgesendet. Die Implementation des Servers wurde bewusst so minimal als möglich gehalten.

\subsection{Clock}
Source: \textit{/code/server/Clock.c}\\
Die Clock wird zu Beginn mit der aktuellen Systemzeit initialisiert. Anschliessend wird mit Hilfe der POSIX-Alarm Funktion jede Sekunde eine Funktion getriggert, die die Zeit erhöht. Dabei werden die Standardmässigen Regeln für die Zeitzählung angewendet.
\begin{itemize}
\item 1 Minute: 60 Sekunden
\item 1 Stunde: 60 Sekunden
\item 1 Tag: 24 Stunden
\item 
\begin{itemize}
\item Januar, März, Mai, Juli, August, Oktober, Dezember: 1 Monat: 31 Tage 
\item April, Juni, September, November: 1 Monat:30 Tage
\item Februar:
\begin{itemize}
\item Aktuelles Jahr ist ein Schaltjahr: 29 Tage 
\item Aktuelles Jahr ist kein Schaltjahr: 28 Tage
\end{itemize}
\end{itemize}
\item 1 Jahr: 365 Tage (366 Tage in einem Schaltjahr)
\end{itemize}

Das Schaltjahr wird wie folgt berechnet. Grundsätzlich gilt: Ist die aktuelle Jahreszahl ohne Rest durch 4 teilbar ist dies ein Schaltjahr. Ist das Jahr wiederum restlos durch 100 teilbar handelt es sich um kein Schaltjahr. Zusätzlich gilt, dass es sich wieder um ein Schaltjahr, wenn das Jahr restlos durch 400 teilbar ist.

Die Uhr bietet eine Funktion an, mit welchem die Zeit "`synchronisiert"' und auf einen bestimmten Wert gesetzt werden kann.Bei der Synchronisierung wird eine Plausibilisierung der zu synchronisierenden Zeit vorgenommen. Es werden dabei nachfolgende Regeln für die Überprüfung angewendet. Wir haben uns bewusst dafür entschieden die Validierung nur bis auf Stunden-Ebene zu implementieren da je nach Empfangsqualität nur einige wenige Signale vom DCF77 empfangen werden können.

\begin{itemize}
\item Jahr: 
	\begin{itemize}
		\item Jahr entspricht aktuellem Jahr
		\item Jahr entspricht dem nächsten Jahr
			\begin{itemize}
				\item Monat entspricht dem Januar
				\item Tag entspricht dem 01.
			\end{itemize}
		\item Jahr entspricht dem letzten Jahr
			\begin{itemize}
				\item Monat entspricht dem Dezember
				\item Tag entspricht dem 31.
			\end{itemize}
	\end{itemize}
\item Monat:
	\begin{itemize}
		\item Monat entspricht aktuellem Monat
		\item Monat entspricht dem nächsten Monat
			\begin{itemize}
				\item Tag entspricht dem 01.
			\end{itemize}
		\item Monat entspricht dem letzten Monat
			\begin{itemize}
				\item Tag entspricht dem letzten des letzten Monats.
			\end{itemize}
	\end{itemize}
\item Tag:
\begin{itemize}
	\item Tag entspricht aktuellem Tag
	\item Tag entspricht dem nächsten Tag
		\begin{itemize}
			\item Stunde entspricht 0.
		\end{itemize}
	\item Tag entspricht dem letzten Tag
		\begin{itemize}
			\item Stunde entspricht 23.
		\end{itemize}
\end{itemize}
\item Stunde:
	\begin{itemize}
		\item Stunde entspricht aktueller Stunde
		\item Stunde ist grösser gleich die vorletzte Stunde.
		\item Stunde ist kleiner gleich der übernächsten Stunde.
	\end{itemize}
\end{itemize}

Das aktuelle Jahr (Monat, Tag, Stunde) bezeichnet die aktuelle Zeit der Clock (vor der Synchronisation).

Um konkurrierende Zugriffe zu verhindern werden Semaphoren eingesetzt.

Uns ist bewusst, dass die aktuelle Implementation der Uhr je nach Systemlast unterschiedlich stark abweichen kann. Hier mussten wir jedoch aus zeitlichen Gründen einen Kompromiss eingehen. Ursprünglich war angedacht, dass für die Bestimmung einer Sekunde der System-Tic verwendet wird. Dieser generiert 18.2 mal in der Sekunde einen entsprechenden Tic / Interrupt. Die Registrierung einer entsprechenden Interrupt Service Routine oder das explizite Abfragen des Tics erfordert unter allen modernen Betriebssystemen höhere Rechte (Kernel Mode). Dafür müsste entweder ein eigener Geräte-Treiber oder ein Kernel-Modul implementiert werden. Da wir auch nach einigen Anläufen keine funktionierende Lösung realisieren konnten, haben wir uns für die Implementation der vereinfachten Variante entschieden.

\section{System-Voraussetzungen}
Für die Ausführung sind gelten folgende Systemvoraussetzungen:

\begin{itemize}
\item OS: Windows oder Mac OSX (32- und 64-bit)
\item Cygwin-Installation
\end{itemize}

\section{Installationsanleitung - DCF77-Treiber}
\subsection{OSX}
Für das Auslesen der Daten wird der D2xx Treiber genutzt. Eine genau Anleitung zur Installation ist in folgendem Dokument in Kapitel "`3.2 Installing D2xx Drivers"' (Seite 9) beschrieben.

Im Git Repo unter:\\
\textit{/analyse/AN\_134\_FTDI\_Drivers\_Installation\_Guide\_for\_MAC\_OSX.pdf}

\subsection{Windows}
Um die Applikation unter Windows zu kompilieren muss der Pfad zu den Treiber-Libraries dem Kompilier bekannt gegeben werden.

\section{Betrieb}
\subsection{Server}
Im Verzeichnis \textit{code/server} können via \textit{make} die ausführbaren Dateien generiert werden.

\subsection{Client}
Der Client ist komplett in HTML/JS geschrieben und kann deshalb ohne Installation ausgeführt werden.

%\subsection{Raspberry-PI}
